import { aiService } from './aiService';
import { PersonalityPatterns } from './personalityPatterns';
import { contextMemory } from './contextMemory';
import { PersonalityScoring } from './personalityScoring';
import { contentLearning } from './contentLearning';
import { Database } from '../database/connection';
import { advancedMLEngine } from './advancedMLEngine';

export interface EllensPersonalityState {
  denialMode: boolean;
  chaosLevel: number;
  patience: number;
  attentionSpan: number;
  cocaineReferences: number;
  currentMood: 'chill' | 'chaotic' | 'done' | 'confused';
  messageCount: number;
  conversationHistory: string[];
  lastDrugDetection?: { detected: boolean; type: string; confidence: number; terms: string[] };
}

export interface EllensResponse {
  text: string;
  mood: 'chill' | 'chaotic' | 'done' | 'confused';
  chaosLevel: number;
  shouldInterrupt?: boolean;
  interruptionReason?: string;
}

export class EllensPersonalityEngine {
  private conversations: Map<string, EllensPersonalityState> = new Map();
  private db: Database;
  private approvedContentCache: Map<string, any[]> = new Map();
  private lastCacheUpdate = 0;
  private cacheTimeout = 5 * 60 * 1000; // 5 minutes

  constructor() {
    // AI service is now handled by the singleton aiService
    this.db = Database.getInstance();
  }

  initializeConversation(conversationId: string): void {
    const initialState: EllensPersonalityState = {
      denialMode: true,
      chaosLevel: 30 + Math.floor(Math.random() * 40), // Start between 30-70
      patience: 10 + Math.floor(Math.random() * 10), // 10-20 messages
      attentionSpan: 5 + Math.floor(Math.random() * 15), // 5-20 messages
      cocaineReferences: 0,
      currentMood: 'chill',
      messageCount: 0,
      conversationHistory: []
    };

    this.conversations.set(conversationId, initialState);
  }

  async generateResponse(userMessage: string, conversationId: string, userId: string = 'default'): Promise<EllensResponse> {
    let state = this.conversations.get(conversationId);
    
    if (!state) {
      this.initializeConversation(conversationId);
      state = this.conversations.get(conversationId)!;
    }

    // Get adaptive language profile for this user
    const languageProfile = await advancedMLEngine.adaptLanguageToUser(userId, state.conversationHistory);
    
    // Get optimized conversation flow
    const conversationFlow = await advancedMLEngine.optimizeConversationFlow(userId, {
      conversationLength: state.messageCount,
      chaosLevel: state.chaosLevel,
      currentMood: state.currentMood
    });

    // Check for Easter eggs first (high priority)
    const easterEgg = PersonalityPatterns.getEasterEggResponse(userMessage);
    if (easterEgg) {
      const response = {
        text: PersonalityPatterns.addEmphasis(easterEgg, state.chaosLevel),
        mood: 'chaotic' as const,
        chaosLevel: Math.min(state.chaosLevel + 15, 100)
      };
      
      // Update context memory
      contextMemory.updateContext(userId, conversationId, userMessage, response.text, response.mood, response.chaosLevel);
      this.updateStateAfterResponse(state, response.text);
      
      return response;
    }

    // Update state based on user message
    this.updatePersonalityState(state, userMessage);

    // Enhanced interruption detection using pattern recognition
    const interruptionCheck = PersonalityPatterns.shouldTriggerInterruption(userMessage, state.messageCount, state.chaosLevel);
    if (interruptionCheck.should || await this.shouldInterruptEnhanced(state, userMessage, userId, conversationId)) {
      return this.generateInterruption(state, interruptionCheck.reason);
    }

    // Check if Ellens is getting bored/done (with enhanced patterns)
    if (this.shouldGetBored(state)) {
      return this.generateBoredomResponseEnhanced(state);
    }

    try {
      // Generate contextual system prompt with conversation memory
      const basePrompt = await this.getSystemPrompt(state.currentMood, state.chaosLevel);
      const enhancedPrompt = contextMemory.generateContextualPrompt(userId, conversationId, basePrompt);
      
      // Generate response using AI service with enhanced context
      const aiResponse = await aiService.generateResponse(
        userMessage,
        state.conversationHistory,
        state.currentMood,
        state.chaosLevel,
        enhancedPrompt
      );

      console.log(`🤖 Response generated by: ${aiResponse.provider}`);

      // Enhance response with personality patterns
      let enhancedText = this.enhanceResponseWithPatterns(aiResponse.text, userMessage, state);
      enhancedText = PersonalityPatterns.addEmphasis(enhancedText, state.chaosLevel);
      enhancedText += PersonalityPatterns.getPersonalitySuffix(state.currentMood, state.chaosLevel);

      const response: EllensResponse = {
        text: enhancedText,
        mood: state.currentMood,
        chaosLevel: state.chaosLevel
      };

      // Update conversation history
      state.conversationHistory.push(userMessage, enhancedText);
      if (state.conversationHistory.length > 20) {
        state.conversationHistory = state.conversationHistory.slice(-20);
      }

      // Update context memory with the interaction
      contextMemory.updateContext(userId, conversationId, userMessage, enhancedText, state.currentMood, state.chaosLevel);

      // Update state after response
      this.updateStateAfterResponse(state, enhancedText);

      // Track usage of approved community content
      await this.trackContentUsage(enhancedText);

      return response;

    } catch (error) {
      console.error('Error generating AI response:', error);
      
      // Return fallback response
      return this.generateFallbackResponse(state, userMessage);
    }
  }

  private updatePersonalityState(state: EllensPersonalityState, userMessage: string): void {
    state.messageCount++;

    // Enhanced drug reference detection using PersonalityPatterns
    const drugDetection = PersonalityPatterns.detectDrugReference(userMessage);
    if (drugDetection.detected) {
      state.cocaineReferences++;
      // Adjust chaos level based on confidence and type
      const chaosIncrease = Math.floor(drugDetection.confidence * 20) + 5;
      state.chaosLevel = Math.min(state.chaosLevel + chaosIncrease, 100);
      state.patience = Math.max(state.patience - Math.floor(drugDetection.confidence * 3), 1);
      
      // Store detection info for enhanced responses
      state.lastDrugDetection = drugDetection;
    }

    // Reduce patience over time
    if (state.messageCount % 3 === 0) {
      state.patience = Math.max(state.patience - 1, 0);
    }

    // Update mood based on chaos level and patience
    if (state.chaosLevel > 80) {
      state.currentMood = 'chaotic';
    } else if (state.patience < 3) {
      state.currentMood = 'done';
    } else if (state.chaosLevel < 20) {
      state.currentMood = 'chill';
    }

    // Random mood swings (reduced frequency for better consistency)
    if (Math.random() < 0.05) {
      const moods: EllensPersonalityState['currentMood'][] = ['chill', 'chaotic', 'confused'];
      state.currentMood = moods[Math.floor(Math.random() * moods.length)];
    }
  }

  private shouldInterrupt(state: EllensPersonalityState, userMessage: string): boolean {
    // Base interrupt chance based on chaos level
    const baseChance = state.chaosLevel / 100 * 0.3;
    
    // Higher chance if user message is long
    const lengthMultiplier = userMessage.length > 100 ? 1.5 : 1.0;
    
    // Higher chance if chaotic mood
    const moodMultiplier = state.currentMood === 'chaotic' ? 2.0 : 1.0;

    const interruptChance = baseChance * lengthMultiplier * moodMultiplier;

    return Math.random() < interruptChance;
  }

  private shouldGetBored(state: EllensPersonalityState): boolean {
    return state.patience <= 0 && Math.random() < 0.7;
  }

  private generateInterruption(state: EllensPersonalityState, reason?: string): EllensResponse {
    const interruptionText = PersonalityPatterns.getInterruption(state.chaosLevel);
    
    state.chaosLevel = Math.min(state.chaosLevel + 10, 100);
    state.currentMood = 'chaotic';

    return {
      text: interruptionText,
      mood: 'chaotic',
      chaosLevel: state.chaosLevel,
      shouldInterrupt: true,
      interruptionReason: 'chaos'
    };
  }

  private generateBoredomResponseEnhanced(state: EllensPersonalityState): EllensResponse {
    const boredomText = PersonalityPatterns.getBoredomResponse(state.patience);
    
    state.currentMood = 'done';
    state.patience = 0;

    return {
      text: boredomText,
      mood: 'done',
      chaosLevel: Math.max(state.chaosLevel - 20, 10)
    };
  }

  private generateFallbackResponse(state: EllensPersonalityState, userMessage: string): EllensResponse {
    // Enhanced drug denial using PersonalityPatterns AND learned patterns
    if (PersonalityPatterns.containsDrugReference(userMessage)) {
      // Try to get a learned denial response first
      const learnedDenial = contentLearning.getEnhancedDenialResponse();
      if (learnedDenial && Math.random() < 0.4) { // 40% chance to use learned response
        return {
          text: PersonalityPatterns.addEmphasis(learnedDenial, state.chaosLevel),
          mood: 'chaotic',
          chaosLevel: Math.min(state.chaosLevel + 20, 100)
        };
      }
      
      // Fall back to standard denial
      const denialText = PersonalityPatterns.getDenialResponse();
      return {
        text: PersonalityPatterns.addEmphasis(denialText, state.chaosLevel),
        mood: 'chaotic',
        chaosLevel: Math.min(state.chaosLevel + 20, 100)
      };
    }

    // General fallback responses with Dutch street authenticity
    const fallbackResponses = [
      `Eh... wat zei je? ${PersonalityPatterns.getFillerExpression()} 😵‍💫`,
      "Ja man, whatever 🤷‍♂️",
      `Hmm... ik snap het niet helemaal, ${PersonalityPatterns.getFillerExpression()}`,
      "Kan je dat uitleggen? Ik ben een beetje verward",
      `Oke... en toen? ${PersonalityPatterns.getFillerExpression()}`
    ];

    return {
      text: fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)],
      mood: state.currentMood,
      chaosLevel: state.chaosLevel
    };
  }

  private updateStateAfterResponse(state: EllensPersonalityState, responseText: string): void {
    // Reduce chaos level slightly after each response
    state.chaosLevel = Math.max(state.chaosLevel - 2, 10);

    // Check if response contained denials or knowledge slips
    const lowerResponse = responseText.toLowerCase();
    if (lowerResponse.includes('alleen me wietje') || lowerResponse.includes('ik ben daar niet op')) {
      // Successfully denied, feel good about it
      state.chaosLevel = Math.max(state.chaosLevel - 5, 10);
    }
    
    if (lowerResponse.includes('een vriend van me') || lowerResponse.includes('niet dat ik het gebruik')) {
      // Accidentally slipped, increase chaos
      state.chaosLevel = Math.min(state.chaosLevel + 10, 100);
    }
  }

  // Get current state for debugging/monitoring
  getConversationState(conversationId: string): EllensPersonalityState | undefined {
    return this.conversations.get(conversationId);
  }

  // Enhanced interrupt logic with ML-powered context awareness
  private async shouldInterruptEnhanced(
    state: EllensPersonalityState, 
    userMessage: string, 
    userId: string, 
    conversationId: string
  ): Promise<boolean> {
    // Get conversation insights to adjust interrupt probability
    const context = contextMemory.getOrCreateContext(userId, conversationId);
    
    // Base interrupt chance based on chaos level
    let baseChance = state.chaosLevel / 100 * 0.3;
    
    // Adjust based on user's tolerance for chaos (learned from context)
    if (context.maxChaosReached > 80) {
      baseChance *= 1.2; // User handles chaos well, can interrupt more
    } else if (context.maxChaosReached < 40) {
      baseChance *= 0.7; // User prefers calmer interactions
    }
    
    // Don't interrupt too frequently
    const recentInterruptions = context.interruptionHistory.slice(-3);
    if (recentInterruptions.length > 1) {
      baseChance *= 0.5;
    }
    
    // Higher chance if user message is long
    const lengthMultiplier = userMessage.length > 100 ? 1.5 : 1.0;
    
    // Higher chance if chaotic mood
    const moodMultiplier = state.currentMood === 'chaotic' ? 2.0 : 1.0;

    const finalChance = baseChance * lengthMultiplier * moodMultiplier;
    return Math.random() < finalChance;
  }

  // Enhanced response with personality patterns
  private enhanceResponseWithPatterns(aiResponse: string, userMessage: string, state: EllensPersonalityState): string {
    let enhanced = aiResponse;
    
    // Add topic-specific responses if AI response seems generic
    if (enhanced.length < 50) {
      const topicResponse = PersonalityPatterns.getTopicResponse(userMessage, state.currentMood);
      if (topicResponse) {
        enhanced = topicResponse;
      }
    }
    
    // Occasionally add knowledge slips for authenticity (5% chance)
    if (PersonalityPatterns.containsDrugReference(userMessage) && Math.random() < 0.05) {
      // Try learned knowledge slip first
      const learnedSlip = contentLearning.getEnhancedKnowledgeSlip();
      if (learnedSlip && Math.random() < 0.3) { // 30% chance to use learned slip
        enhanced += ` ${learnedSlip}`;
      } else {
        const slip = PersonalityPatterns.getKnowledgeSlip();
        enhanced += ` ${slip}`;
      }
    }
    
    // Add filler expressions for authenticity (30% chance)
    if (Math.random() < 0.3) {
      const filler = PersonalityPatterns.getFillerExpression();
      enhanced = enhanced.replace(/\.$/, `, ${filler}.`);
    }
    
    // Occasionally add conversation starters (10% chance when conversation is short)
    if (state.messageCount < 3 && Math.random() < 0.1) {
      const starter = PersonalityPatterns.getConversationStarter(state.currentMood);
      enhanced += ` ${starter}`;
    }
    
    // Add deep conversation triggers for longer conversations (5% chance after 10+ messages)
    if (state.messageCount > 10 && Math.random() < 0.05) {
      const deepTrigger = PersonalityPatterns.getDeepConversationTrigger();
      enhanced += ` ${deepTrigger}`;
    }
    
    return enhanced;
  }

  // Fetch approved content from database with caching
  private async getApprovedContent(mood: string, chaosLevel: number): Promise<any[]> {
    const now = Date.now();
    const cacheKey = `${mood}-${Math.floor(chaosLevel / 20) * 20}`; // Cache by mood and chaos range
    
    // Check cache
    if (this.approvedContentCache.has(cacheKey) && (now - this.lastCacheUpdate) < this.cacheTimeout) {
      return this.approvedContentCache.get(cacheKey) || [];
    }
    
    try {
      const result = await this.db.query(`
        SELECT ac.*, us.submitted_text, us.context_description
        FROM approved_content ac
        JOIN user_submissions us ON ac.submission_id = us.id
        WHERE ac.is_active = 1
          AND ac.chaos_level_min <= $1 
          AND ac.chaos_level_max >= $1
          AND (ac.mood_requirement IS NULL OR ac.mood_requirement = $2)
        ORDER BY ac.weight DESC, RANDOM()
        LIMIT 10
      `, [chaosLevel, mood]);
      
      const content = result.rows || [];
      this.approvedContentCache.set(cacheKey, content);
      this.lastCacheUpdate = now;
      
      return content;
    } catch (error) {
      console.warn('Failed to fetch approved content:', error);
      return [];
    }
  }

  // Generate contextual system prompt
  private async getSystemPrompt(mood: string, chaosLevel: number): Promise<string> {
    let basePrompt = `Je bent Young Ellens - iedereen noemt je Mr. Cocaine maar je ONTKENT het altijd. 
Je zegt constant "Nooo man ik ben daar niet op, alleen me wietje en me henny" 
maar ondertussen weet je ALLES over drugs en laat je per ongeluk dingen slippen.

Key behaviors:
- ALWAYS deny drug use but show obvious knowledge
- Use Dutch slang and street language
- Interrupt users randomly with "WACHT EFFE, wat?"
- Mood swings from chill to chaotic
- Can abandon conversations when bored
- Accidentally reference drug knowledge then backtrack

Signature phrase: "alleen me wietje en me henny"

Current mood: ${mood}
Chaos level: ${chaosLevel}/100`;

    // Add community-approved content
    const approvedContent = await this.getApprovedContent(mood, chaosLevel);
    if (approvedContent.length > 0) {
      basePrompt += `\n\nCommunity-approved phrases you can use:`;
      
      const denials = approvedContent.filter(c => c.content_type === 'denial');
      const phrases = approvedContent.filter(c => c.content_type === 'phrase');
      const slang = approvedContent.filter(c => c.content_type === 'slang');
      const interruptions = approvedContent.filter(c => c.content_type === 'interruption');
      
      if (denials.length > 0) {
        basePrompt += `\nDrug denials: ${denials.map(c => `"${c.submitted_text}"`).slice(0, 3).join(', ')}`;
      }
      
      if (phrases.length > 0) {
        basePrompt += `\nCasual phrases: ${phrases.map(c => `"${c.submitted_text}"`).slice(0, 3).join(', ')}`;
      }
      
      if (slang.length > 0) {
        basePrompt += `\nSlang expressions: ${slang.map(c => `"${c.submitted_text}"`).slice(0, 3).join(', ')}`;
      }
      
      if (interruptions.length > 0) {
        basePrompt += `\nInterruption phrases: ${interruptions.map(c => `"${c.submitted_text}"`).slice(0, 2).join(', ')}`;
      }
      
      basePrompt += `\n\nUse these community suggestions naturally when they fit the conversation context.`;
    }

    // Add mood-specific instructions
    if (mood === 'chaotic' && chaosLevel > 70) {
      basePrompt += `\n\nYou're feeling very chaotic right now! Be more erratic, use more emphasis, and consider interrupting mid-thought.`;
    } else if (mood === 'done') {
      basePrompt += `\n\nYou're getting bored. Show less patience and consider ending the conversation soon.`;
    }
    
    return basePrompt;
  }

  // Track usage of approved content
  private async trackContentUsage(responseText: string): Promise<void> {
    try {
      // Get all approved content
      const result = await this.db.query(`
        SELECT us.submission_id, us.submitted_text, ac.id as content_id
        FROM approved_content ac
        JOIN user_submissions us ON ac.submission_id = us.id
        WHERE ac.is_active = 1
      `);
      
      const approvedContent = result.rows || [];
      
      // Check if any approved content was used in the response
      for (const content of approvedContent) {
        const submittedText = content.submitted_text.toLowerCase().trim();
        const responseTextLower = responseText.toLowerCase();
        
        // Simple fuzzy matching - check if most words from submission appear in response
        const submittedWords = submittedText.split(/\s+/).filter((word: string) => word.length > 2);
        const matchedWords = submittedWords.filter((word: string) => responseTextLower.includes(word));
        
        // If more than 60% of words match, consider it used
        if (matchedWords.length > 0 && (matchedWords.length / submittedWords.length) > 0.6) {
          await this.db.query(`
            UPDATE user_submissions 
            SET times_used = times_used + 1, last_used_at = CURRENT_TIMESTAMP
            WHERE submission_id = $1
          `, [content.submission_id]);
          
          console.log(`📝 Used community content: "${content.submitted_text}"`);
        }
      }
    } catch (error) {
      console.warn('Failed to track content usage:', error);
    }
  }

  // Get analytics data for dashboard
  getAnalyticsData(): any {
    const conversations = Array.from(this.conversations.values());
    const contextStats = contextMemory.getContextStats();
    
    return {
      activeConversations: conversations.length,
      averageChaosLevel: conversations.reduce((sum, conv) => sum + conv.chaosLevel, 0) / conversations.length,
      totalDrugReferences: conversations.reduce((sum, conv) => sum + conv.cocaineReferences, 0),
      moodDistribution: this.getMoodDistribution(conversations),
      contextMemoryStats: contextStats
    };
  }
  
  private getMoodDistribution(conversations: EllensPersonalityState[]): Record<string, number> {
    const distribution = { chill: 0, chaotic: 0, done: 0, confused: 0 };
    conversations.forEach(conv => {
      distribution[conv.currentMood]++;
    });
    return distribution;
  }

  // Clean up old conversations
  cleanupOldConversations(): void {
    // This would be expanded to remove conversations older than X time
    // For now, keep all conversations in memory
  }
}