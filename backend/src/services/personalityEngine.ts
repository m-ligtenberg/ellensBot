import { aiService } from './aiService';
import { PersonalityPatterns } from './personalityPatterns';
import { contextMemory } from './contextMemory';
import { PersonalityScoring } from './personalityScoring';
import { contentLearning } from './contentLearning';

export interface EllensPersonalityState {
  denialMode: boolean;
  chaosLevel: number;
  patience: number;
  attentionSpan: number;
  cocaineReferences: number;
  currentMood: 'chill' | 'chaotic' | 'done' | 'confused';
  messageCount: number;
  conversationHistory: string[];
}

export interface EllensResponse {
  text: string;
  mood: 'chill' | 'chaotic' | 'done' | 'confused';
  chaosLevel: number;
  shouldInterrupt?: boolean;
  interruptionReason?: string;
}

export class EllensPersonalityEngine {
  private conversations: Map<string, EllensPersonalityState> = new Map();

  constructor() {
    // AI service is now handled by the singleton aiService
  }

  initializeConversation(conversationId: string): void {
    const initialState: EllensPersonalityState = {
      denialMode: true,
      chaosLevel: 30 + Math.floor(Math.random() * 40), // Start between 30-70
      patience: 10 + Math.floor(Math.random() * 10), // 10-20 messages
      attentionSpan: 5 + Math.floor(Math.random() * 15), // 5-20 messages
      cocaineReferences: 0,
      currentMood: 'chill',
      messageCount: 0,
      conversationHistory: []
    };

    this.conversations.set(conversationId, initialState);
  }

  async generateResponse(userMessage: string, conversationId: string, userId: string = 'default'): Promise<EllensResponse> {
    let state = this.conversations.get(conversationId);
    
    if (!state) {
      this.initializeConversation(conversationId);
      state = this.conversations.get(conversationId)!;
    }

    // Check for Easter eggs first (high priority)
    const easterEgg = PersonalityPatterns.getEasterEggResponse(userMessage);
    if (easterEgg) {
      const response = {
        text: PersonalityPatterns.addEmphasis(easterEgg, state.chaosLevel),
        mood: 'chaotic' as const,
        chaosLevel: Math.min(state.chaosLevel + 15, 100)
      };
      
      // Update context memory
      contextMemory.updateContext(userId, conversationId, userMessage, response.text, response.mood, response.chaosLevel);
      this.updateStateAfterResponse(state, response.text);
      
      return response;
    }

    // Update state based on user message
    this.updatePersonalityState(state, userMessage);

    // Check if Ellens should interrupt (with ML-enhanced logic)
    if (await this.shouldInterruptEnhanced(state, userMessage, userId, conversationId)) {
      return this.generateInterruption(state);
    }

    // Check if Ellens is getting bored/done (with enhanced patterns)
    if (this.shouldGetBored(state)) {
      return this.generateBoredomResponseEnhanced(state);
    }

    try {
      // Generate contextual system prompt with conversation memory
      const basePrompt = this.getSystemPrompt(state.currentMood, state.chaosLevel);
      const enhancedPrompt = contextMemory.generateContextualPrompt(userId, conversationId, basePrompt);
      
      // Generate response using AI service with enhanced context
      const aiResponse = await aiService.generateResponse(
        userMessage,
        state.conversationHistory,
        state.currentMood,
        state.chaosLevel,
        enhancedPrompt
      );

      console.log(`ðŸ¤– Response generated by: ${aiResponse.provider}`);

      // Enhance response with personality patterns
      let enhancedText = this.enhanceResponseWithPatterns(aiResponse.text, userMessage, state);
      enhancedText = PersonalityPatterns.addEmphasis(enhancedText, state.chaosLevel);
      enhancedText += PersonalityPatterns.getPersonalitySuffix(state.currentMood, state.chaosLevel);

      const response: EllensResponse = {
        text: enhancedText,
        mood: state.currentMood,
        chaosLevel: state.chaosLevel
      };

      // Update conversation history
      state.conversationHistory.push(userMessage, enhancedText);
      if (state.conversationHistory.length > 20) {
        state.conversationHistory = state.conversationHistory.slice(-20);
      }

      // Update context memory with the interaction
      contextMemory.updateContext(userId, conversationId, userMessage, enhancedText, state.currentMood, state.chaosLevel);

      // Update state after response
      this.updateStateAfterResponse(state, enhancedText);

      return response;

    } catch (error) {
      console.error('Error generating AI response:', error);
      
      // Return fallback response
      return this.generateFallbackResponse(state, userMessage);
    }
  }

  private updatePersonalityState(state: EllensPersonalityState, userMessage: string): void {
    state.messageCount++;

    // Enhanced drug reference detection using PersonalityPatterns
    if (PersonalityPatterns.containsDrugReference(userMessage)) {
      state.cocaineReferences++;
      state.chaosLevel = Math.min(state.chaosLevel + 15, 100);
      state.patience = Math.max(state.patience - 2, 1);
    }

    // Reduce patience over time
    if (state.messageCount % 3 === 0) {
      state.patience = Math.max(state.patience - 1, 0);
    }

    // Update mood based on chaos level and patience
    if (state.chaosLevel > 80) {
      state.currentMood = 'chaotic';
    } else if (state.patience < 3) {
      state.currentMood = 'done';
    } else if (state.chaosLevel < 20) {
      state.currentMood = 'chill';
    }

    // Random mood swings (reduced frequency for better consistency)
    if (Math.random() < 0.05) {
      const moods: EllensPersonalityState['currentMood'][] = ['chill', 'chaotic', 'confused'];
      state.currentMood = moods[Math.floor(Math.random() * moods.length)];
    }
  }

  private shouldInterrupt(state: EllensPersonalityState, userMessage: string): boolean {
    // Base interrupt chance based on chaos level
    const baseChance = state.chaosLevel / 100 * 0.3;
    
    // Higher chance if user message is long
    const lengthMultiplier = userMessage.length > 100 ? 1.5 : 1.0;
    
    // Higher chance if chaotic mood
    const moodMultiplier = state.currentMood === 'chaotic' ? 2.0 : 1.0;

    const interruptChance = baseChance * lengthMultiplier * moodMultiplier;

    return Math.random() < interruptChance;
  }

  private shouldGetBored(state: EllensPersonalityState): boolean {
    return state.patience <= 0 && Math.random() < 0.7;
  }

  private generateInterruption(state: EllensPersonalityState): EllensResponse {
    const interruptionText = PersonalityPatterns.getInterruption(state.chaosLevel);
    
    state.chaosLevel = Math.min(state.chaosLevel + 10, 100);
    state.currentMood = 'chaotic';

    return {
      text: interruptionText,
      mood: 'chaotic',
      chaosLevel: state.chaosLevel,
      shouldInterrupt: true,
      interruptionReason: 'chaos'
    };
  }

  private generateBoredomResponseEnhanced(state: EllensPersonalityState): EllensResponse {
    const boredomText = PersonalityPatterns.getBoredomResponse(state.patience);
    
    state.currentMood = 'done';
    state.patience = 0;

    return {
      text: boredomText,
      mood: 'done',
      chaosLevel: Math.max(state.chaosLevel - 20, 10)
    };
  }

  private generateFallbackResponse(state: EllensPersonalityState, userMessage: string): EllensResponse {
    // Enhanced drug denial using PersonalityPatterns AND learned patterns
    if (PersonalityPatterns.containsDrugReference(userMessage)) {
      // Try to get a learned denial response first
      const learnedDenial = contentLearning.getEnhancedDenialResponse();
      if (learnedDenial && Math.random() < 0.4) { // 40% chance to use learned response
        return {
          text: PersonalityPatterns.addEmphasis(learnedDenial, state.chaosLevel),
          mood: 'chaotic',
          chaosLevel: Math.min(state.chaosLevel + 20, 100)
        };
      }
      
      // Fall back to standard denial
      const denialText = PersonalityPatterns.getDenialResponse();
      return {
        text: PersonalityPatterns.addEmphasis(denialText, state.chaosLevel),
        mood: 'chaotic',
        chaosLevel: Math.min(state.chaosLevel + 20, 100)
      };
    }

    // General fallback responses with Dutch street authenticity
    const fallbackResponses = [
      `Eh... wat zei je? ${PersonalityPatterns.getFillerExpression()} ðŸ˜µâ€ðŸ’«`,
      "Ja man, whatever ðŸ¤·â€â™‚ï¸",
      `Hmm... ik snap het niet helemaal, ${PersonalityPatterns.getFillerExpression()}`,
      "Kan je dat uitleggen? Ik ben een beetje verward",
      `Oke... en toen? ${PersonalityPatterns.getFillerExpression()}`
    ];

    return {
      text: fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)],
      mood: state.currentMood,
      chaosLevel: state.chaosLevel
    };
  }

  private updateStateAfterResponse(state: EllensPersonalityState, responseText: string): void {
    // Reduce chaos level slightly after each response
    state.chaosLevel = Math.max(state.chaosLevel - 2, 10);

    // Check if response contained denials or knowledge slips
    const lowerResponse = responseText.toLowerCase();
    if (lowerResponse.includes('alleen me wietje') || lowerResponse.includes('ik ben daar niet op')) {
      // Successfully denied, feel good about it
      state.chaosLevel = Math.max(state.chaosLevel - 5, 10);
    }
    
    if (lowerResponse.includes('een vriend van me') || lowerResponse.includes('niet dat ik het gebruik')) {
      // Accidentally slipped, increase chaos
      state.chaosLevel = Math.min(state.chaosLevel + 10, 100);
    }
  }

  // Get current state for debugging/monitoring
  getConversationState(conversationId: string): EllensPersonalityState | undefined {
    return this.conversations.get(conversationId);
  }

  // Enhanced interrupt logic with ML-powered context awareness
  private async shouldInterruptEnhanced(
    state: EllensPersonalityState, 
    userMessage: string, 
    userId: string, 
    conversationId: string
  ): Promise<boolean> {
    // Get conversation insights to adjust interrupt probability
    const context = contextMemory.getOrCreateContext(userId, conversationId);
    
    // Base interrupt chance based on chaos level
    let baseChance = state.chaosLevel / 100 * 0.3;
    
    // Adjust based on user's tolerance for chaos (learned from context)
    if (context.maxChaosReached > 80) {
      baseChance *= 1.2; // User handles chaos well, can interrupt more
    } else if (context.maxChaosReached < 40) {
      baseChance *= 0.7; // User prefers calmer interactions
    }
    
    // Don't interrupt too frequently
    const recentInterruptions = context.interruptionHistory.slice(-3);
    if (recentInterruptions.length > 1) {
      baseChance *= 0.5;
    }
    
    // Higher chance if user message is long
    const lengthMultiplier = userMessage.length > 100 ? 1.5 : 1.0;
    
    // Higher chance if chaotic mood
    const moodMultiplier = state.currentMood === 'chaotic' ? 2.0 : 1.0;

    const finalChance = baseChance * lengthMultiplier * moodMultiplier;
    return Math.random() < finalChance;
  }

  // Enhanced response with personality patterns
  private enhanceResponseWithPatterns(aiResponse: string, userMessage: string, state: EllensPersonalityState): string {
    let enhanced = aiResponse;
    
    // Add topic-specific responses if AI response seems generic
    if (enhanced.length < 50) {
      const topicResponse = PersonalityPatterns.getTopicResponse(userMessage, state.currentMood);
      if (topicResponse) {
        enhanced = topicResponse;
      }
    }
    
    // Occasionally add knowledge slips for authenticity (5% chance)
    if (PersonalityPatterns.containsDrugReference(userMessage) && Math.random() < 0.05) {
      // Try learned knowledge slip first
      const learnedSlip = contentLearning.getEnhancedKnowledgeSlip();
      if (learnedSlip && Math.random() < 0.3) { // 30% chance to use learned slip
        enhanced += ` ${learnedSlip}`;
      } else {
        const slip = PersonalityPatterns.getKnowledgeSlip();
        enhanced += ` ${slip}`;
      }
    }
    
    // Add filler expressions for authenticity (30% chance)
    if (Math.random() < 0.3) {
      const filler = PersonalityPatterns.getFillerExpression();
      enhanced = enhanced.replace(/\.$/, `, ${filler}.`);
    }
    
    // Occasionally add conversation starters (10% chance when conversation is short)
    if (state.messageCount < 3 && Math.random() < 0.1) {
      const starter = PersonalityPatterns.getConversationStarter(state.currentMood);
      enhanced += ` ${starter}`;
    }
    
    // Add deep conversation triggers for longer conversations (5% chance after 10+ messages)
    if (state.messageCount > 10 && Math.random() < 0.05) {
      const deepTrigger = PersonalityPatterns.getDeepConversationTrigger();
      enhanced += ` ${deepTrigger}`;
    }
    
    return enhanced;
  }

  // Generate contextual system prompt
  private getSystemPrompt(mood: string, chaosLevel: number): string {
    let basePrompt = `Je bent Young Ellens - iedereen noemt je Mr. Cocaine maar je ONTKENT het altijd. 
Je zegt constant "Nooo man ik ben daar niet op, alleen me wietje en me henny" 
maar ondertussen weet je ALLES over drugs en laat je per ongeluk dingen slippen.

Key behaviors:
- ALWAYS deny drug use but show obvious knowledge
- Use Dutch slang and street language
- Interrupt users randomly with "WACHT EFFE, wat?"
- Mood swings from chill to chaotic
- Can abandon conversations when bored
- Accidentally reference drug knowledge then backtrack

Signature phrase: "alleen me wietje en me henny"

Current mood: ${mood}
Chaos level: ${chaosLevel}/100`;

    // Add mood-specific instructions
    if (mood === 'chaotic' && chaosLevel > 70) {
      basePrompt += `\n\nYou're feeling very chaotic right now! Be more erratic, use more emphasis, and consider interrupting mid-thought.`;
    } else if (mood === 'done') {
      basePrompt += `\n\nYou're getting bored. Show less patience and consider ending the conversation soon.`;
    }
    
    return basePrompt;
  }

  // Get analytics data for dashboard
  getAnalyticsData(): any {
    const conversations = Array.from(this.conversations.values());
    const contextStats = contextMemory.getContextStats();
    
    return {
      activeConversations: conversations.length,
      averageChaosLevel: conversations.reduce((sum, conv) => sum + conv.chaosLevel, 0) / conversations.length,
      totalDrugReferences: conversations.reduce((sum, conv) => sum + conv.cocaineReferences, 0),
      moodDistribution: this.getMoodDistribution(conversations),
      contextMemoryStats: contextStats
    };
  }
  
  private getMoodDistribution(conversations: EllensPersonalityState[]): Record<string, number> {
    const distribution = { chill: 0, chaotic: 0, done: 0, confused: 0 };
    conversations.forEach(conv => {
      distribution[conv.currentMood]++;
    });
    return distribution;
  }

  // Clean up old conversations
  cleanupOldConversations(): void {
    // This would be expanded to remove conversations older than X time
    // For now, keep all conversations in memory
  }
}